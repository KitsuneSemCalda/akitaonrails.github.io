---
title: Ruby, a linguagem do mundo Cloud
date: '2013-10-29T10:49:00-02:00'
slug: ruby-a-linguagem-do-mundo-cloud
tags:
- rails
- pitch
- cloud-computing
draft: false
---

Ruby on Rails é definitivamente o primeiro motivo para qualquer novo programador se interessar por Ruby. É um framework muito estável que conquistou uma posição de destaque. Atualmente criou-se um ecossistema que expandiu além do framework e gerou uma coleção de bibliotecas, ferramentas e serviços. O pacote básico oferece muito: desde um excelente suporte a MVC-Web. O sistema de roteamento ainda é excepcional mesmo comparado a outros frameworks. Apesar de controverso o ORM ActiveRecord evoluiu e se tornou muito estável. Novos patterns de organização como [Presenters](http://stackoverflow.com/questions/7860301/rails-patterns-decorator-vs-presenter), [Service Objects](http://blog.codeclimate.com/blog/2012/10/17/7-ways-to-decompose-fat-activerecord-models/), [Concerns](http://37signals.com/svn/posts/3372-put-chubby-models-on-a-diet-with-concerns) surgiram para facilitar aplicativos maiores. Pacotes como [Minitest](http://blog.crowdint.com/2013/06/14/testing-rails-with-minitest.html), [RSpec](https://github.com/rspec/rspec-rails), [Factory Girl](https://github.com/thoughtbot/factory_girl), [Fabricator](http://www.fabricationgem.org) e outros continuam a tornar os testes mais e mais completos. Também controverso o [Asset Pipeline](http://www.akitaonrails.com/2012/07/01/asset-pipeline-para-iniciantes) faz o que todo framework deveria fazer como básico: minificar e otimizar assets. 

O mundo front-end evoluiu além do JQuery. É trivial integrar os novos frameworks como [Backbone](https://github.com/codebrew/backbone-rails), [Angular](https://shellycloud.com/blog/2013/10/how-to-integrate-angularjs-with-rails-4), [Ember](http://hashrocket.com/blog/posts/setting-up-an-ember-app-with-a-rails-backend). O mundo de CSS também evoluiu além do [Sass](https://github.com/rails/sass-rails), temos facilmente integrado [Twitter Bootstrap](http://railsapps.github.io/rails-bootstrap/), Foundation e outros. E o mundo de templates evoluiu além do ERB e [HAML](http://haml.info) com exemplos como [Slim](http://slim-lang.com). Enfim, existem opções simples para todos os gostos.

E para facilitar a vida durante o desenvolvimento temos servicos como [CodeClimate](http://codeclimate.com/) para análise estática de código, [Travis-CI](https://travis-ci.org) para integração contínua. New Relic continua sendo uma opções completa e robusta de monitoramento em produção e melhoria contínua.

E se quisermos explorar além do básico ainda temos o mundo de NoSQL, [Mongoid](http://mongoid.org/en/mongoid/docs/rails.html) é a melhor opção para MongoDB. O melhor sistema de execução de tarefas assíncronas é o [Sidekiq](http://sidekiq.org), que usa Redis. Integrar cache com Memcached chega a ser trivial. E tudo isso numa arquitetura que continua se mantendo "shared nothing", garantindo nossa opções de escalabilidade horizontal.

E se o Ruby MRI não é mais suficiente, sempre temos a opção de usar [JRuby](https://devcenter.heroku.com/articles/moving-an-existing-rails-app-to-run-on-jruby) e ganhar alta performance com poucas (ou às vezes nenhuma) mudança de código. E com isso temos diversas opções de servidores de aplicação com [Unicorn](https://devcenter.heroku.com/articles/rails-unicorn), [Passenger](https://www.eventials.com/pt-br/locaweb/superalimentando-seus-deployments-com-phusion-passenger-4/) e [Puma](http://puma.io).

Mais do que isso, depois que o tema "assíncrono" ficou na moda por causa de node.js, surgiram diversos serviços que solucionam todos os use cases. Não há mais necessidade de se preocupar com comunicação assíncrona com serviços como [Pusher](https://www.eventials.com/pt-br/locaweb/do-loop-de-eventos-a-sistemas-distribuidos/), [PubNub](http://www.pubnub.com) e [diversos outros](https://www.quora.com/What-are-alternatives-to-pusher-com).

O stack está bastante completo, é uma combinação muito difícil de equiparar. E além disso o mundo Ruby está evoluindo para outras direções. Uma constatação importante: hoje o mundo está se movendo para a virtualização de servidores e automação de infraestrutura. O primeiro grande exemplo e ainda a melhor opção da categoria que ficou conhecida como IaaS (Infrastructure as a Service) é Amazon Web Services (AWS) EC2. Temos outros como Rackspace Cloud, Digital Ocean e no mundo não-open source temos Microsoft Azure.

Mas nós do mundo Ruby usamos uma categoria acima faz alguns anos: o chamado PaaS (Platform as a Service). A opção mais conhecida é sem dúvida o [Heroku](http://www.akitaonrails.com/2012/04/20/heroku-tips-enciclopedia-do-heroku) onde com um mero "git push" fazemos deployment em quantos servidores quisermos. Além dele ainda temos o [Engine Yard Cloud](https://www.engineyard.com/products/cloud). Agora outra coisa interessante, dentre as maiores opções temos ainda os recém-chegados [RedHat OpenShift](http://openshift.github.io), [VMWare Cloud Foundry](http://cloudfoundry.org), até certo ponto também o Microsoft Azure, a própria Amazon com o [AWS Elastic Beanstalk](http://ruby.awsblog.com/post/Tx2AK2MFX0QHRIO/Deploying-Ruby-Applications-to-AWS-Elastic-Beanstalk-with-Git), [AWS Opsworks](http://docs.aws.amazon.com/opsworks/latest/userguide/workinglayers-rails.html), e o Google com uma opção mais restrita que é o Google App Engine. Existem outros mas vamos ficar com esses mais conhecidos, 7 opções e delas 5 utilizam ferramental e tecnologias Ruby.

O mundo Ruby está evoluindo isso faz algum tempo, começando com ferramentas de automação de infraestrutura que tentam tratar o mundo de hardware como se fosse software e nessa categoria temos [Puppet](http://puppetlabs.com/blog/ruby-dsl), [Chef](http://www.opscode.com/chef/). Sobre esse ferramental, novas tecnologias como [Bosh](https://github.com/cloudfoundry/bosh) foram criadas. Essas tecnologias permitiram Heroku, Engine Yard, OpenShift, Cloud Foundry, e o próprio AWS OpsWorks (que é uma interface Web sobre Chef).

Essa evolução no mundo de ferramental de Cloud retorna ao mundo de desenvolvimento mesmo no desktop com ferramentas como [Vagrant](https://github.com/cloudfoundry/bosh), que automatiza a montagem do seu ambiente de desenvolvimento. Integrado com ferramentas como o Chef e facilitadores como [Berkshelf](http://berkshelf.com), temos uma enorme biblioteca para montar ambiente complicados, podemos inclusive configurar rapidamente um ambiente inteiro [Cloud Foundry sobre Vagrant](https://github.com/Altoros/cf-vagrant-installer).

O que quero dizer com isso? O mundo Cloud não está chegando: ele já está aqui. O ecossistema Ruby colaborou muito no bootstrap do novo mundo Front-end, influenciando práticas, tecnologias e agora faz o mesmo no mundo Back-end, diretamente no motor do Cloud. Além disso o ecossistema permeia hoje todas as etapas de uma solução completa: front-end, back-end, infraestrutura, além de Java, poucos ecossistemas são tão verticais.

Dicas? Comece a estudar ecossistemas como Chef e evoluções de ferramentas como Vagrant. Saber Rails, saber fazer testes automatizados, saber fazer front-end com pipeline automatizado, já pode ser considerado o básico.
